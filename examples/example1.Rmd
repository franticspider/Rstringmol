---
title: "Stringmol run analysis"
output:
  pdf_document: default
  html_notebook: default
---


# Popdy

First thing we want is overall pop size in a file. This function is in `14.04/home/sjh/Desktop/sjh/stringmol/R/plotpopdy.R`

```{r}
plot.onepop <- function(infn,outfn,w,h, col.fun=rainbow, totpop = F, plotnspp = F, log = "", time.lim= NA, minpop=0){
	x	<- read.table(infn,sep=",", col.names=c('time', 'species', 'count'))
	
	if(is.na(time.lim))
	  time.lim <- range(x$time)
	
	valid.species <- unique(x$species)
	colours <- col.fun(length(valid.species))
	
	if(totpop){
	  times <- as.data.frame(unique(x$time))
	  times$pop <- 0
	  colnames(times) <- c("time","pop")
	  for(tt in 1:nrow(times)){
	    data <- x[x$time == times$time[tt],]
	    times$pop[tt] = sum(data$count)
	  }
	  
	  tpmax =max(times$pop)
	}
	else{
	  tpmax=0
	}
	
	
	
	if(plotnspp){
	  nspp <- as.data.frame(unique(x$time))
	  nspp$nspp <- 0
	  colnames(nspp) <- c("time","nspp")
	  for(tt in 1:nrow(times)){
	    data <- x[x$time == times$time[tt],]
	    nspp$nspp[tt] <- nrow(data)
	  }
	  #return(nspp)
	}
	
	y.lim <- c(1, max(x$count,tpmax))#max(x$count))
	# pdf(file=outfn, height=h, width=w, title=outfn)
	#  	par(mar=c(5,5, 0.1, 0.1))
	plot(NA, xlim=time.lim, ylim=y.lim, ann=FALSE, axes=FALSE, log = log )
	sapply(1:length(valid.species), function(i){
		data <- x[x$species==valid.species[i],]
		if(max(data$count > minpop))
		  lines(x=data$time, y=data$count + 0.1, col=colours[i])
	})
	
	if(totpop)
		  lines(x=times$time,y=times$pop,lwd=2,col="red")
	
	
	axis(2, las=2)
	title(ylab='population')
	x.positions <- seq(from=time.lim[1], to=time.lim[2], length.out=20)
	axis(1, at=x.positions, labels=sprintf('%d', x.positions / 1e3))
	
	
	if(plotnspp){
	  par(new = T)
	  plot(x=nspp$time,y=nspp$nspp,axes=F,xlab=NA,ylab=NA,type="l",lty=2,col="green")
	  axis(side=4)
	}
	
	
	title(xlab=expression(time%*%10^3))
	#box()
	# dev.off()
}


plot.onepop("~/Desktop/paulien/confs/out3/popdy001.dat","example1popdy.pdf",12,12,minpop=100, totpop=T,plotnspp = T)
```


Concerns:
- this only records pop every 10000 timesteps - potentially many generations between recordings. Understandable though - if we find a particular feature, we can go back and rerun to get more detail. 
- Nothing here about species length - need to grab that info from the right spplists file
- Need a sanity check on the species numbers via the spplists (since we are purging these).

# Community structure

## stats

### Stats from `splist` files

Theres a function called `splist_stats` that generates these - let's check it out: 

```{r}
source("../R/splist_stats.R")
sps <- splist_stats("~/Desktop/paulien/confs/out3/splist300000.dat",tmin=290000)
```

That works, so let's see if we can do an iteration: 

```{r}
gotdata<- T
tt <- 10000
while(gotdata){
  fn <- sprintf("~/Desktop/paulien/confs/out3/splist%d.dat",tt)
  if(file.exists(fn)){
    message(sprintf("\nProcessing Time %d:",tt))
    splist_stats(fn,tmin=(tt-10000))
  }
  else
    gotdata <- F
  
  tt = tt+10000
}
```
That works as far as it goes, but we aren't seeing the *dominant* reaction that we are looking for, just the "most common reaction that first occured withing 10000 time steps". 

### Stats from `.conf` files

If we want the commonest reaction at time x, we might be better to look at the out1*conf files - these are a snapshot of the current system by definition - these will take a little more work to interpret however, but they will be exact. We might even be able to use these to develop a network of what is going on...

Each entry for a reaction in the current state of the system looks like this: 
    
    %%% REACTION 718
    REACTION
    ###############  8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOB
    REACTION_ACTIVE  8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOBWWGEWLHHHRLUEUWJJJRNJXUUUDGRGJ irwf: 1 0 49 0 30 16 1 0 94 1 0 46 grid: 165 39  pass_index: 1629
    
    PASSIVE
    REACTION_PASSIVE 8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOB grid: 166 40
    ###############  8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOB
    
    AGENT  JJRNJXUUUDGRHJLRWWRE$BLUBO^>C$=?>$$BUBOUB$=?>$$=?>$$BLUBO%}OYHOB 1 Q
    GRIDPOS  190 30
    
    AGENT  $BLUBO^>C$=?>$$BUBOUBO^B>C$=?>$$BLUBO%}OYHOB 1 Q
    GRIDPOS  189 29


```{r}
require (stringr)

source("../R/splist_stats.R")

####Function 'arguments'
  fn <- "~/Desktop/paulien/confs/out3/out1_100000.conf"
  verbose <- T
  spldata <-  splist_stats("~/Desktop/paulien/confs/out3/splist100000.dat")

####Function 'body'

  cf <- read.table(fn,as.is = T, fill = T, sep="\n",comment.char="",stringsAsFactors = F)
  
  #get the row number of the start of each reaction entry
  rpos <- which(str_sub(cf[,1],1,12)=="%%% REACTION")
  
  #build the data for each reaction - similar to the splist analysis
  for(rr in 1:length(rpos)){
    words <-strsplit(cf[rpos[rr]+2,1],split=" ")
    actno[rr] <- as.numeric(words[[1]][3])
    actseq[rr] <- words[[1]][4]
    words <-strsplit(cf[rpos[rr]+6,1],split=" ")
    pasno[rr] <- words[[1]][3]
    passeq[rr] <- as.numeric(words[[1]][4])
    message(sprintf("Active  molecule %s seq %s",actno[rr],actseq[rr]))
    message(sprintf("Passive molecule %s seq %s",actno[rr],actseq[rr]))
  }
  
  eachreaction<-data.frame(actno,actseq,pasno,passeq)
  
  reactions <- unique(eachreaction)
  reactions$type = "<unknown>"
  
  for(rr in 1:nrow(reactions)){
    ca <- eachreaction[eachreaction$actno == reactions$actno[rr] & eachreaction$pasno == reactions$pasno[rr],]
    reactions$count[rr] = nrow(ca)
  }
  
  
  

```




## Changes in community structure over time


# Ancestry
