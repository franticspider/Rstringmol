---
title: "Stringmol run analysis"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

# prelims

Set the `froot` variable to the path to the files for these tests:

```{r}
froot="D:/sjh/stringmol/out3smsp/"
#froot="~/Desktop/paulien/confs/out3/"
```


# Popdy

First thing we want is overall pop size in a file. This function is in `14.04/home/sjh/Desktop/sjh/stringmol/R/plotpopdy.R`

```{r}
plot.onepop <- function(infn,outfn,w,h, col.fun=rainbow, totpop = F, plotnspp = F, log = "", time.lim= NA, minpop=0){
	x	<- read.table(infn,sep=",", col.names=c('time', 'species', 'count'))
	
	#diagnostics
	message(sprintf("Reading file %s",infn))
	message(sprintf("Read %d lines",nrow(x)))
	
	
	if(is.na(time.lim))
	  time.lim <- range(x$time)
	
	valid.species <- unique(x$species)
	colours <- col.fun(length(valid.species))
	
	if(totpop){
	  times <- as.data.frame(unique(x$time))
	  times$pop <- 0
	  colnames(times) <- c("time","pop")
	  for(tt in 1:nrow(times)){
	    data <- x[x$time == times$time[tt],]
	    times$pop[tt] = sum(data$count)
	  }
	  
	  tpmax =max(times$pop)
	}
	else{
	  tpmax=0
	}
	
	
	
	if(plotnspp){
	  nspp <- as.data.frame(unique(x$time))
	  nspp$nspp <- 0
	  colnames(nspp) <- c("time","nspp")
	  for(tt in 1:nrow(times)){
	    data <- x[x$time == times$time[tt],]
	    nspp$nspp[tt] <- nrow(data)
	  }
	  #return(nspp)
	}
	
	y.lim <- c(1, max(x$count,tpmax))#max(x$count))
	# pdf(file=outfn, height=h, width=w, title=outfn)
	#  	par(mar=c(5,5, 0.1, 0.1))
	plot(NA, xlim=time.lim, ylim=y.lim, ann=FALSE, axes=FALSE, log = log )
	sapply(1:length(valid.species), function(i){
		data <- x[x$species==valid.species[i],]
		if(max(data$count > minpop))
		  lines(x=data$time, y=data$count + 0.1, col=colours[i])
	})
	
	if(totpop)
		  lines(x=times$time,y=times$pop,lwd=2,col="red")
	
	
	axis(2, las=2)
	title(ylab='population')
	x.positions <- seq(from=time.lim[1], to=time.lim[2], length.out=20)
	axis(1, at=x.positions, labels=sprintf('%d', as.integer(x.positions / 1e3)))
	
	
	if(plotnspp){
	  par(new = T)
	  plot(x=nspp$time,y=nspp$nspp,axes=F,xlab=NA,ylab=NA,type="l",lty=2,col="green")
	  axis(side=4)
	}
	
	
	title(xlab=expression(time%*%10^3))
	#box()
	# dev.off()
	
	#legend()
	
}


plot.onepop(sprintf("%spopdy001.dat",froot),"example1popdy.pdf",12,12,minpop=100, totpop=T,plotnspp = T)
segments(x0=100000,y0=0,y1=1200,col="blue")
```

the blue line indicates $t=100000$ - which is where the splist and out1 files explored below relate to. 

Concerns:
- this only records pop every 10000 timesteps - potentially many generations between recordings. Understandable though - if we find a particular feature, we can go back and rerun to get more detail. 
- Nothing here about species length - need to grab that info from the right spplists file
- Need a sanity check on the species numbers via the spplists (since we are purging these).

# Community structure

## stats

### Stats from `splist` files

Theres a function called `splist_stats` that generates these - let's check it out: 

```{r}
source("../R/splist_stats.R")
sps <- splist_stats(sprintf("%ssplist100000.dat",froot),tmin=90000)
```

That works, so let's see if we can do an iteration: 

```{r}
gotdata<- T
tt <- 10000
while(gotdata){
  fn <- sprintf("%ssplist%d.dat",froot,tt)
  if(file.exists(fn)){
    message(sprintf("\nProcessing Time %d:",tt))
    splist_stats(fn,tmin=(tt-10000))
  }
  else
    gotdata <- F
  
  tt = tt+10000
}
```
That works as far as it goes, but we aren't seeing the *dominant* reaction that we are looking for, just the "most common reaction that first occured withing 10000 time steps". 

### Stats from `.conf` files

If we want the commonest reaction at time x, we might be better to look at the out1*conf files - these are a snapshot of the current system by definition - these will take a little more work to interpret however, but they will be exact. We might even be able to use these to develop a network of what is going on...

Each entry for a reaction in the current state of the system looks like this: 
    
    %%% REACTION 718
    REACTION
    ###############  8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOB
    REACTION_ACTIVE  8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOBWWGEWLHHHRLUEUWJJJRNJXUUUDGRGJ irwf: 1 0 49 0 30 16 1 0 94 1 0 46 grid: 165 39  pass_index: 1629
    
    PASSIVE
    REACTION_PASSIVE 8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOB grid: 166 40
    ###############  8557 WWGEWLHHHRLUEUWJJJRNJXUUUDGRGJLRWWRE$BLUBO^B>C$=?>$$BLUBO%}OYHOB
    
    AGENT  JJRNJXUUUDGRHJLRWWRE$BLUBO^>C$=?>$$BUBOUB$=?>$$=?>$$BLUBO%}OYHOB 1 Q
    GRIDPOS  190 30
    
    AGENT  $BLUBO^>C$=?>$$BUBOUBO^B>C$=?>$$BLUBO%}OYHOB 1 Q
    GRIDPOS  189 29


```{r}
require (stringr)

source("../R/splist_stats.R")

####Function 'arguments'
  fn <- sprintf("%sout1_100000.conf",froot)
  verbose <- T
  spldata <-  splist_stats(sprintf("%ssplist100000.dat",froot))

####Function 'body'

  cf <- read.table(fn,as.is = T, fill = T, sep="\n",comment.char="",stringsAsFactors = F)
  
  #get the row number of the start of each reaction entry
  rpos <- which(str_sub(cf[,1],1,12)=="%%% REACTION")
  
  nr <- length(rpos)
  actno <- vector(length = nr)
  actseq <- vector(length = nr)
  pasno <- vector(length = nr)
  passeq <- vector(length = nr)
  
  #build the data for each reaction - similar to the splist analysis
  for(rr in 1:nr){
    words <-strsplit(cf[rpos[rr]+2,1],split=" ")
    actno[rr] <- as.numeric(words[[1]][3])
    actseq[rr] <- words[[1]][4]
    words <-strsplit(cf[rpos[rr]+6,1],split=" ")
    pasno[rr] <- as.numeric(words[[1]][3])
    passeq[rr] <- words[[1]][4]
    #message(sprintf("Active  molecule %s seq %s",actno[rr],actseq[rr]))
    #message(sprintf("Passive molecule %s seq %s",actno[rr],actseq[rr]))
  }
  
  eachreaction<-data.frame(actno,actseq,pasno,passeq)
  
  reactions <- unique(eachreaction)
  reactions$type = "<unknown>"
  
  for(rr in 1:nrow(reactions)){
    ca <- eachreaction[eachreaction$actno == reactions$actno[rr] & eachreaction$pasno == reactions$pasno[rr],]
    reactions$count[rr] = nrow(ca)
  }
  reactions <- reactions[order(reactions$count,decreasing = T),]
  
  #Get the product molecule from the splist: 
  for(rr in 1:nrow(reactions)){
    
    if(is.na(reactions$actno[rr]) || is.na(reactions$pasno[rr])){
      
        #message(sprintf("Reaction %d has NAs  (NA)",rr))
        reactions$type[rr]= "na"
        next
    }
    
    
    dd <- spldata[(spldata$act == reactions$actno[rr]) & (spldata$pass == reactions$pasno[rr]), ]
    if(nrow(dd)==0){
      #message(sprintf("Reaction %d has no product (NP)",rr))
      reactions$type[rr]= "NP"
    }
    if(reactions$actno[rr] == reactions$pasno[rr]){
      if(nrow(dd)==1){
        if(dd$spp == reactions$actno[rr]){
          #message(sprintf("Reaction %d is an exact self:self replicator (ER)*",rr))
          reactions$type[rr]= "ER"
        }
        else{
          #message(sprintf("Self:self reaction with different product (DP)*",rr))
          reactions$type[rr]= "DP"
        }
      }
      if(nrow(dd)>1){
        #message(sprintf("Reaction %d is a pathological replicator (PR)",rr))
        reactions$type[rr]= "PR"
      }
    }
    else{
      if(nrow(dd)==1){
        if(dd$spp == reactions$pasno[rr]){
          #message(sprintf("Reaction %d is parsitic (PA)*",rr))
        reactions$type[rr]= "PA"
        }
        else{
          #message(sprintf("non-self reaction with different product (DN)*",rr))
          reactions$type[rr]= "DN"
        }
      }
      if(nrow(dd)>1){
        #message(sprintf("Reaction %d is a pathological non-self replicator (PN)",rr))
        reactions$type[rr]= "PN"
      }
    }
    
    
  }

```


Check that we've now got this in a function: 

```{r}
source("../R/rconf_stats.R")
reactions <- rconf_stats(fn = sprintf("%sout1_100000.conf",froot), spfn = sprintf("%ssplist100000.dat",froot))
```



Now we can count the different reaction types: 


```{r}

rclass <- c("NA","NP","ER","DP","PR","PA","DN","PN")
rcounts <- data.frame(rclass)
for(rr in 1:length(rclass)){
  dd <- reactions[reactions$type == rclass[rr],]
  rcounts$count[rr] = nrow(dd)
}

```

That works, so let's see if we can do an iteration: 

```{r}
source("../R/splist_stats.R")
source("../R/rconf_stats.R")

gotdata<- T
tt <- 20000
#rcounts <- data.frame(rclass)
rcounts <- data.frame(time=0,"NA"=0,NP=0,ER=1,DP=0,PR=0,PA=0,DN=0,PN=0)
rsumcounts <- data.frame(time=0,"NA"=0,NP=0,ER=500,DP=0,PR=0,PA=0,DN=0,PN=0)
count <- vector(length = length(rclass))
scount <- vector(length = length(rclass))
count <- 0
sumcount <- 0
rno<-2

while(gotdata ){#&& tt < 320000){
  message(sprintf("Processing time %d",tt))
  fn <- sprintf("%ssplist%d.dat",froot,tt)
  spfn <- sprintf("%sout1_%d.dat",froot,tt)
  if(file.exists(fn)){
    message(sprintf("\nProcessing Time %d:",tt))
    reactions <- rconf_stats(fn = sprintf("%sout1_%d.conf",froot,tt), spfn = sprintf("%ssplist%d.dat",froot,tt))
    
    
    if(is.na(reactions)){
    }
    else{
    
      count <- 0
      sumcount <- 0
      
      for(rr in 1:length(rclass)){
        
        dd <- reactions[reactions$type == rclass[rr],]
        count[rr] <- nrow(dd)
        sumcount[rr] <- sum(dd$count)
      }
      #assign(sprintf("t%d",tt))
      
      trow = c(tt,t(count))
      rcounts <- rbind(rcounts,trow)
      
      trow = c(tt,t(sumcount))
      rsumcounts <- rbind(rsumcounts,trow)
      #colnames(rcounts)[rno] <- sprintf("t%d",tt)
      
      #rno <- rno + 1
    }
    
  }
  else{
    gotdata <- F
  }
  tt = tt+20000
}
#Now we can plot the change in diversity: 
#https://www.r-graph-gallery.com/stacked-barplot/
```


```{r fig.height=8, fig.width=10}
bcols = rainbow(ncol(rcounts[2:9]))
par(mfrow=c(2,1))
barplot(t(rcounts[2:9]),col=bcols,border=bcols,names=rcounts[,1],las=2,main="Reaction Types")
cn <-colnames(rcounts)
legend("topleft",legend=rev(cn[2:9]),fill=rev(bcols),border=rev(bcols))

barplot(t(rsumcounts[2:9]),col=bcols,border=bcols,names=rcounts[,1],las=2,main="Reaction Counts")
cn <-colnames(rcounts)
legend("topleft",legend=rev(cn[2:9]),fill=rev(bcols),border=rev(bcols))
#legend("topleft",legend=(cn[2:9]),fill=(bcols),border=(bcols))
```

## Handling the warnings...

let's look at t=80000 again and make sure we are handling warnings properly. 

```{r}

source("../R/splist_stats.R")
source("../R/rconf_stats.R")
tt <- 80000
spfn = sprintf("%ssplist%d.dat",froot,tt)
spldata <-  splist_stats(spfn)
reactions <- rconf_stats(fn = sprintf("%sout1_%d.conf",froot,tt), spfn, verbose = T)

```

## Changes in community structure over time


# Ancestry
